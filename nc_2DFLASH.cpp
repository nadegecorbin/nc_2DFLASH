//-----------------------------------------------------------------------------
//  Copyright (C) Siemens AG 1998-2006  All Rights Reserved.  Confidential
//-----------------------------------------------------------------------------
//
// Project: NUMARIS/4
//
//    File: \n4_servers1\pkg\MrServers\MrImaging\seq\nc_2DFLASH\nc_2DFLASH.cpp
//
// Authors: Mark Brown;       SMS MED US CSG TDC;
//          Brian Dale;       SMS MED US CSG MR R&D;
//          Wolfgang Rehwald; SMS MED US CSG MR R&D;
//          Keith Heberlein;  SMS MED US CSG MR R&D;
//
//          Original Author: Anonymous
//
//    Lang: C++
//
// Descrip: This is the demo sequence nc_2DFLASH.
//          DO NOT base any diagnosis on images generated by this sequence.
//
//////////////////////////////////////////////////////////////////////////////////////////
//
//                                nc_2DFLASH Sequence Diagram
//
//                       |-----------TE---------------|
//
//              RF --|m_sSRF01|----------------------------------------------
//
//              Gs -|m_sGSliSel|-|m_sGSliSelReph|-----------|m_sGSpoil|------
//
//              Gp --------------|m_sGPhasEnc|--------------|m_sGPhasEncRew|-
//
//              Gr --------------|m_sGReadDeph|---|m_sGradRO|----------------
//
//             ADC --------------------------------|m_sADC01|----------------
//
//                |------------------------------TR--------------------------|
//
///////////////////////////////////////////////////////////////////////////////////////////


#include "MrServers/MrImaging/seq/nc_2DFLASH/nc_2DFLASH.h"
#include "MrServers/MrImaging/seq/nc_2DFLASH/nc_2DFLASH_UI.h"

#include "MrServers/MrMeasSrv/SeqIF/csequence.h"                        // Sequence enumerations
#include "MrServers/MrImaging/libSeqSysProp/SysProperties.h"            // System properties ("imprint" data)
#include "MrServers/MrImaging/ut/libsequt.h"                            // Unit Test


// Macro: return S, if S is an error code (applies to functions returning MRRESULT-values)
#define OnErrorReturn(S) if(!MrSucceeded(S)) return(S)


#ifndef SEQ_NAMESPACE
    #error SEQ_NAMESPACE not defined
#endif

#define SEQ_NAME "flls1a"

//  --------------------------------------------------------------------------
//
//  Name        :  SEQIF_DEFINE
//
//  Description :
///  \brief        Create instance of the sequence
//
//  Return      :  SeqIF *
//
//  --------------------------------------------------------------------------
#ifdef SEQUENCE_CLASS_nc_2DFLASH
     SEQIF_DEFINE (SEQ_NAMESPACE::nc_2DFLASH)
#endif
using namespace SEQ_NAMESPACE;

nc_2DFLASH::nc_2DFLASH()
            : m_dRFSpoilPhase       (0.0)
            , m_dRFSpoilIncrement   (0.0)
            , m_lCenterLine         (0)
            , m_dMinRiseTime        (100000.0)
            , m_dGradMaxAmpl        (0.0)
            , m_lLinesPerSec        (0)
			, m_lLinesToMeasure     (0)
			, m_sSRF01              ("fl_templ_ex")
            , m_sSRF01zSet          ("sSRF01zSet")
            , m_sSRF01zNeg          ("sSRF01zNeg")
            , m_sADC01              ("sADC01")
            , m_sADC01zSet          ("sADC01zSet")
            , m_sADC01zNeg          ("sADC01zNeg")
            , m_sGSliSel            ("sGSliSel")
            , m_sGSliSelReph        ("sGSliSelReph")
            , m_sGradRO             ("m_sGradRO")
            , m_sGReadDeph          ("m_sGReadDeph")
            , m_sGPhasEnc           ("sGPhasEnc")
            , m_sGPhasEncRew        ("sGPhasEncRew")
            , m_sGSpoil             ("m_sGSpoil")
            , m_sOscBit             ("m_sOscBit")
			, m_lRepToMeasure		(0)
			, m_lNbOfMeas          (1)
            , m_pUI                 (NULL)
			, m_lNbDummies           (5)
			, m_dBWT                (2.3)
			, m_lPulseDur           (2000)
			, m_WIPParamTool		(*this)
{
    // no further instructions...
}


nc_2DFLASH::~nc_2DFLASH()
{
    if(NULL != m_pUI)
    {
        // delete the user interface (UI) instance (if a UI instance has been created)
        delete m_pUI;
        m_pUI = NULL;
    }
}


//   -------------------------------------------------------------------------
//   nc_2DFLASH::initialize
//   Initialize the allowed Sequence Limits.
//   These entries enable user interface parameters in the exam window,
//   or initialize other parameters of the sequence.
//   -------------------------------------------------------------------------

NLSStatus nc_2DFLASH::initialize(SeqLim &rSeqLim)
{
    // This string is intended to identify where we are in the code (used for debugging by the MRTRACE macro).
    static const char *ptModule = {"nc_2DFLASH::initialize"};

    // Default return value
    NLS_STATUS lStatus = SEQU__NORMAL;

	m_WIPParamTool.createLongParameter (lWIPPulseDur,0, rSeqLim,"RFdur", "usec", 100, 10000, 10, m_lPulseDur);

	m_WIPParamTool.createDoubleParameter (dWIPPulseBWT,1, rSeqLim,"BWT", "", 0.1, 1.0, 40.0, 0.1, m_dBWT);

	m_WIPParamTool.createLongParameter (lWIPDummies,2, rSeqLim,"nDummies", "", 0, 10000, 1, m_lNbDummies);

    //  The parameters in this group have no meaningful default value (zero or not specified in SeqLim).

    //                                (        min,        max)
    rSeqLim.setAllowedFrequency     (    8000000,  500000000);                         // Always refers to 1H frequency

    //                                (index,  min,        max,    increment,  default)
    rSeqLim.setTR                   (    0,  100,    5000000,           10,    20000);
    rSeqLim.setTE                   (    0,  100,     100000,           10,    10000);
    rSeqLim.setBandWidthPerPixel    (    0,   80,        900,           10,      260);

    //                              (        min,        max,    increment,  default)
    rSeqLim.setFlipAngle            (       1.0,       90.0,          1.0,   5.000);


    //  These parameters have default values, yet are added for convenience

    //                              (        min,        max,    increment,  default)
	rSeqLim.setBaseResolution       (         64,        512,  SEQ::INC_16,      128); // INC_BASE2 also available
    rSeqLim.setReadoutFOV           (        100,        500,            1,      300); // mm
    rSeqLim.setPhaseFOV             (        100,        500,            1,      300); // mm
    rSeqLim.setPELines              (         32,       1024,            1,      128);
    rSeqLim.setSlices               (          1,          1,            1,        1); // Only single slice!
    rSeqLim.setSliceThickness       (      0.500,     10.000,        0.500,    5.000); // mm

	rSeqLim.setRepetitions			(          0,     10000,             1,			10);

    // --------------------------------------
    // Instantiation of the nc_2DFLASHUI class
    // --------------------------------------

    // MRRESULT_SEV is a mask for the "severity" bits. This if-statement checks whether the severity bits
    // are set (which indicates that something went wrong).
    if((MRRESULT_SEV & (lStatus = createUI(rSeqLim))) == MRRESULT_SEV) 
    {
        // The MRTRACE macro is used to log information for debugging purposes
        MRTRACE("Instantiation of nc_2DFLASHUI class failed!");
        return lStatus;
    }

    // This compiler directive restricts this code to the Host version dll.
    // In this way the same source code can be compiled for both the Host and the MARS,
    // but different portions of the code can be restricted to one processor.
    // WIN32 is a standard proprocessor flag. User-defined flags are in the makefile.trs.

#ifdef WIN32

    if(NULL == m_pUI) 
    {
        MRTRACE("nc_2DFLASHUI object pointer is null (creation failed probably)!");
        return ( SEQU_ERROR );
    }

    // ----------------------------------------------
    // Declaration of pointer to UI parameter classes
    // ----------------------------------------------
    lStatus = m_pUI->registerUI(rSeqLim);
    if(MrSeverity(lStatus) != MRRESULT_SUCCESS) 
    {
        MRTRACE("Registering nc_2DFLASHUI object failed! Errorcode: %i", lStatus);
        return lStatus;
    }

    // -----------------------------------------------------------------
    // file containing the default postprocessing protocol (EVAProtocol)
    // -----------------------------------------------------------------

    // The _T(x) macro deals with the Unicode conversion of strings.
    rSeqLim.setDefaultEVAProt (_T("%SiemensEvaDefProt%\\Inline\\Inline.evp"));

#endif


    return lStatus;
}

//  -------------------------------------------------------------------------
//   nc_2DFLASH::prepare
//   Prepare real time elements and calculate energy and timing.
//   Values from MrProt are interpreted.
//. -------------------------------------------------------------------------
NLSStatus nc_2DFLASH::prepare(MrProt &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo)
{
	MRTRACE("NC_DEBUG:prepare");
    static const char *ptModule = {"nc_2DFLASH::prepare"};
    NLS_STATUS   lStatus = SEQU__NORMAL;                                         // Default return value

    int32_t lMinRequiredTE, lMinRequiredTR, lPhaseEncTotalTime;
    double dMeasureTimeUsec = 0.0;

	//
	//	Prepare WPT before using any parameters defined within it!
	//
	if (!m_WIPParamTool.prepare (rMrProt, rSeqLim)) return SEQU_ERROR;

    //  Retrieve some information about the scanner and define some convenient variables.
    //  Hardware information is stored in proxy files. The contents can be retrieved using SysProperties methods.

    m_dMinRiseTime = SysProperties::getGradMinRiseTime(rMrProt.gradSpec().mode()); // Minimum gradient rise time
    m_dGradMaxAmpl = SysProperties::getGradMaxAmpl(rMrProt.gradSpec().mode());     // Maximum gradient amplitude
                                                                                   // selected in protocol

    OnErrorReturn(rMrProt.kSpace().linesToMeasure(m_lLinesToMeasure));             // Call by non-constant reference
    m_lCenterLine  = rMrProt.kSpace().echoLine();                                  // 1/2 base resolution for symmetric PE

    dMeasureTimeUsec = (double)m_lLinesToMeasure * rMrProt.tr()[0] * m_lNbOfMeas;
   
	m_lRepToMeasure=rMrProt.repetitions();;
	m_lNbOfMeas=m_lRepToMeasure+1;

	m_lNbDummies=m_WIPParamTool.getLongValue (rMrProt, lWIPDummies);

    // CONFIGURE RF PULSE PROPERTIES AND PREPARE:
	m_lPulseDur=m_WIPParamTool.getLongValue (rMrProt, lWIPPulseDur);
	m_dBWT=m_WIPParamTool.getDoubleValue (rMrProt, dWIPPulseBWT);

    m_sSRF01.setTypeExcitation       ();                                           // Resets all moments to 0 in Unit test
    m_sSRF01.setDuration             (m_lPulseDur);                                       // Most times are in microseconds
    m_sSRF01.setFlipAngle            (rMrProt.flipAngle());                        // Sets flip angle based on UI (in degrees)
    m_sSRF01.setInitialPhase         (0);                                          // Sets B1 orientation to 0 degrees (+x) in rotating frame 
    m_sSRF01.setThickness            (rMrProt.sliceSeries().aFront().thickness()); // Sets thickness based on UI (in mm)
    m_sSRF01.setSamples              (m_lPulseDur);                                        // Number of complex points in waveform
    m_sSRF01.setBandwidthTimeProduct (m_dBWT);                                       // Only sRF_PULSE_SINC objects have the BW*t attribute

	std::cout<<"pulse dur"<<m_sSRF01.getDuration()<<std::endl;
    //  The following is a common error-checking code structure for pulse sequences.
    //  The prepare (prep) method returns a boolean indicating success or failure.
    //  If the returned boolean indicates failure, then exit prepare and return the NLS error code.
    if(! m_sSRF01.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF01.getNLSStatus());

    // PREPARE ADC:
    m_sADC01.setColumns (rMrProt.kSpace().getlBaseResolution());
    m_sADC01.setDwellTime (long((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
    m_sADC01.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution() / 2));

    // An explicit preparation for the ADC is not necessary as setDwellTime() includes .prep

    // PREPARE THE READOUT GRADIENT:
    // The method .prepRO() sets only the amplitude based on the UI settings.
    // The ramp times and the duration need to be set separately.
    // Note that the duration is defined as the RampUpTime plus the FlatTopTime.
    // The method .check() ensures that amplitude and slew rate limits are not exceeded.

    if(!m_sGradRO.prepRO(rMrProt, static_cast<double>( m_sADC01.getDwellTime() ) )) return(m_sGradRO.getNLSStatus());
    m_sGradRO.setRampTimes(fSDSRoundUpGRT(m_dMinRiseTime * m_sGradRO.getAmplitude()));
    m_sGradRO.setDuration(fSDSRoundUpGRT((double)( m_sGradRO.getRampUpTime() + m_sADC01.getDuration() )));
    if(!m_sGradRO.prep()) return (m_sGradRO.getNLSStatus());
    if(!m_sGradRO.check()) return (m_sGradRO.getNLSStatus());

    //  The start time of the readout gradient cannot be set because the slice select gradient timing has not
    //  been determined. Once the TE in the UI is known to be consistent (i.e. if it is greater than the minimum
    //  required TE), the start time can be set.

    //  PREPARE AND CHECK THE PHASE ENCODING GRADIENT:
    //  First, chose maximum allowed value for gradient performance.
    m_sGPhasEnc.setMaxMagnitude(m_dGradMaxAmpl);     // set highest performance value (maximum allowed gradient amplitude)
    m_sGPhasEnc.setMinRiseTime(m_dMinRiseTime);      // set highest performance value (shortest allowed gradient rise time)
    // rise time is 1/slew rate; unit of rise time is [us/(mT/m)]

    //  Second, prepare gradient for positive edge of k-space ...
    if( !m_sGPhasEnc.prepPEShortestTime(rMrProt, SEQ::DIR_ASCENDING, 0.0, m_lLinesToMeasure - m_lCenterLine - 1))
        return(m_sGPhasEnc.getNLSStatus());

    //  .. and check if amplitude and rise time do not exceed maximum allowed values.
    if( !m_sGPhasEnc.check()) return(m_sGPhasEnc.getNLSStatus());

    //  Remember the duration, before praparing the other edge of k-space
    lPhaseEncTotalTime = static_cast<int32_t>( m_sGPhasEnc.getTotalTime() );

    //  Third, prepare gradient for negative edge of k-space ...
    if( !m_sGPhasEnc.prepPEShortestTime(rMrProt, SEQ::DIR_ASCENDING, 0.0, -m_lCenterLine )) return(m_sGPhasEnc.getNLSStatus());

    //  .. and check if amplitude and rise time do not exceed maximum allowed values.
    if( !m_sGPhasEnc.check()) return(m_sGPhasEnc.getNLSStatus());

    //  Take the longer duration of both edges by re-preparing the gradient, if needed
    if (lPhaseEncTotalTime > m_sGPhasEnc.getTotalTime())
    {
        if( !m_sGPhasEnc.prepPEShortestTime(rMrProt, SEQ::DIR_ASCENDING, 0.0, m_lLinesToMeasure - m_lCenterLine - 1))
            return(m_sGPhasEnc.getNLSStatus());
    }

    //  Copy timing info to PE rewinder as this gradient will have same timing (but opposite polarity) as phase encoder.
    m_sGPhasEncRew = m_sGPhasEnc;

    //  PREPARE AND CHECK THE SLICE SELECTION GRADIENT:
    //  First, set the gradient amplitude, retrieving it from the RF pulse object.
    m_sGSliSel.setAmplitude(m_sSRF01.getGSAmplitude());

    //  Second, set the ramp-up and ramp-down times. The variable m_dMinRiseTime is the inverse of the slew rate [us*m/mT],
    //  the .getAmplitude() method delivers the amplitude in mT/m. The coil lead time is the minimum time needed between
    //  the beginning of an event block and the start time of the RF pulse shape. If the needed lead time is longer than
    //  the calculated minimum ramp-up time, then set the ramp-up time to the coil lead time.
    m_sGSliSel.setRampTimes(fSDSRoundUpGRT( std::max<long>((long)(m_dMinRiseTime * m_sGSliSel.getAmplitude()), SysProperties::getCoilCtrlLead())));

    //  Third, set the duration of the gradient. Gradient "duration" is defined as the duration of the ramp-up plus
    //  the duration of the plateau. The ramp-down duration is NOT included.
    m_sGSliSel.setDuration(fSDSRoundUpGRT(m_sSRF01.getDuration() + m_sGSliSel.getRampUpTime()));

	
    //  Fourth, prepare and check if the gradient is correctly prepared (slew rate and maximum amplitude not exceeded).
    if (!m_sGSliSel.prep())  return (m_sGSliSel.getNLSStatus());
    if (!m_sGSliSel.check()) return (m_sGSliSel.getNLSStatus());

    //  Finally, set start time of gradient to zero, as this is the first event in the event block. In general, setting
    //  the start time is not required for passing the check. However, it is required if the gradient is played out
    //  by using the .run() method rather than by using the fRTEI function in the runKernel method.
    //  Setting the start time is also a useful feature for getting timing information, e.g. in runKernel.
    m_sGSliSel.setStartTime(0);

    //  PREPARE AND CHECK THE SLICE REPHASE GRADIENT:
    //  Set the area equal to the slice select gradient from TE = 0 to the end (assuming a symmetric RF pulse).
    //  Use the shortest time possible.
    m_sGSliSelReph.setMaxMagnitude(m_dGradMaxAmpl);
    m_sGSliSelReph.setMinRiseTime (m_dMinRiseTime);
    if (!m_sGSliSelReph.prepSymmetricTOTShortestTime(-m_sGSliSel.getMomentum(m_sGSliSel.getDuration() - m_sSRF01.getDuration() / 2,
        m_sGSliSel.getTotalTime())))
        return (m_sGSliSelReph.getNLSStatus());


    //  PREPARE AND CHECK THE READOUT DEPHASING GRADIENT:
    //  Set the area equal to the readout gradient up to TE (assuming symmetric sampling).
    //  Use the shortest time possible.
    m_sGReadDeph.setMaxMagnitude(m_dGradMaxAmpl);
    m_sGReadDeph.setMinRiseTime (m_dMinRiseTime);
    if (!m_sGReadDeph.prepSymmetricTOTShortestTime(-m_sGradRO.getMomentum(0 , m_sGradRO.getRampUpTime() + (long)m_sADC01.getDuration() / 2)))
        return (m_sGReadDeph.getNLSStatus());


    //  PREPARE AND CHECK THE SPOILER GRADIENT:
    //  Set the area to half that of the slice select gradient, and use the shortest time possible.
    m_sGSpoil.setMaxMagnitude(m_dGradMaxAmpl);
    m_sGSpoil.setMinRiseTime (m_dMinRiseTime);
    if(!m_sGSpoil.prepSymmetricTOTShortestTime(m_sGSliSel.getMomentum(0, m_sGSliSel.getDuration() - m_sSRF01.getDuration() / 2 ))) 
        return (m_sGSpoil.getNLSStatus());


	// TRIGGER 
	// Prepare TTL 
	// 3 ms single trigger pulse
	m_sTTL_Trig.setStartTime (0);
    m_sTTL_Trig.prep (0,3000);




    //  Calculate minimum required TE by finding the time-dominant (longest) gradient of m_sGReadDeph, m_sGPhasEnc, and m_sGSliSelReph.
    //  Note that m_sGSliSelReph is started when m_sGSliSel has ramped down, whereas m_sGReadDeph and m_sGPhasEnc are started at the
    //  end of the plateau of m_sGSliSel.

    //  First, see how long TE needs to be if m_sGReadDeph is longest:
    lMinRequiredTE = static_cast<int32_t>( m_sSRF01.getDuration()/2 + m_sGReadDeph.getTotalTime() + m_sGradRO.getRampUpTime()
        + m_sADC01.getRoundedDuration()/2 );

    //  Second, compare this TE to the TE necessary if m_sGPhasEnc is longest:
    lMinRequiredTE =  static_cast<int32_t>( std::max<long>(lMinRequiredTE, m_sSRF01.getDuration() / 2 + m_sGPhasEnc.getTotalTime()
        + m_sADC01.getRoundedDuration()/2) );

    //  Finally, compare this TE to the TE necessary if m_sGSliSelReph is longest:
    lMinRequiredTE =  std::max<int32_t>(lMinRequiredTE, static_cast<int32_t>( m_sSRF01.getDuration() / 2 + m_sGSliSel.getRampDownTime()
        + m_sGSliSelReph.getTotalTime() + m_sADC01.getRoundedDuration() / 2) );


    //  DETERMINE IF THE REQUIRED TIMING CAN BE ACCOMMODATED BY THE TE IN THE PROTOCOL:
    //  If the minimum required TE is larger than the TE specified in the protocol, then return an error code
    //  �SBB_NEGATIV_TEFILL". This error will cause the UI to increase the TE (pMrProt->te()[0]) until the 
    //  prepare method no longer returns an error. Then the TE value that is found is consistent.
    if (lMinRequiredTE >(rMrProt.te()[0])) return SBB_NEGATIV_TEFILL ;


    //  Set the start time of the readout gradient m_sGradRO
    m_sGradRO.setStartTime(fSDSRoundUpGRT(m_sGSliSel.getDuration() - m_sSRF01.getDuration() / 2 + rMrProt.te()[0]
        - m_sADC01.getRoundedDuration() / 2 - m_sGradRO.getRampUpTime()));

    //  Set the start time of the ADC event m_sADC01
    m_sADC01.setStartTime(m_sGradRO.getStartTime() + m_sGradRO.getRampUpTime());


    //  DETERMINE IF THE REQUIRED TIMING CAN BE ACCOMODATED BY THE TR IN THE PROTOCOL:
    //  If the minimum required TR is larger than the TR chosen in the protocol, then return an error code
    //  "SBB_NEGATIV_TRFILL". This error will cause the UI to increase the TR (pMrProt->tr()[0]) until the 
    //   prepare method no longer returns an error. Then the TR value is found that is consistent.

    lMinRequiredTR = (int32_t)(m_sGSliSel.getDuration() - m_sSRF01.getDuration() / 2 ) + rMrProt.te()[0] + int32_t(m_sADC01.getDuration()/2)
        +  std::max<int32_t>((int32_t)m_sGPhasEncRew.getTotalTime(), (int32_t)m_sGSpoil.getTotalTime());
    if (lMinRequiredTR > rMrProt.tr()[0]) return SBB_NEGATIV_TRFILL ;

    //  PREPARE THE SYNCHRONIZATION EVENT:
    //  Since it occurs at the same time as the slice gradient at the beginning of the event block
    //  and is of shorter duration, it need not be included the timing checks.
    m_sOscBit.setCode(SYNCCODE_OSC0);                                  // Internal designation for port 0
    m_sOscBit.setDuration( 10);                                        // Duration in us

    //  Set receiver gain
    OnErrorReturn(fSSLSetRxGain(K_RX_GAIN_CODE_HIGH, rMrProt, rSeqLim));

    //  Prepare the slice position array
    OnErrorReturn(fSUPrepSlicePosArray (rMrProt, rSeqLim, m_asSLC));

    //  Set sequence string for display in images.
    fSUSetSequenceString               ("fl", rMrProt, rSeqExpo);

    //  Fill export section
    rSeqExpo.setRFInfo                ((m_lNbOfMeas*m_lLinesToMeasure + m_lNbDummies) * m_sSRF01.getRFInfo());        // Mandatory for SAR
    rSeqExpo.setMeasureTimeUsec       (dMeasureTimeUsec + m_lNbDummies * rMrProt.tr()[0]);                                // Mandatory for SAR
    rSeqExpo.setTotalMeasureTimeUsec  (dMeasureTimeUsec  + m_lNbDummies * rMrProt.tr()[0]);                                // Mandatory for SAR
    rSeqExpo.setMeasuredPELines       (m_lLinesToMeasure);                                 // Recommended
    rSeqExpo.setOnlineFFT             (SEQ::ONLINE_FFT_PHASE);                             // Necessary for online reconstruction

    //  An ICE program must be specified in order for the MARS to be active during scan
    rSeqExpo.setICEProgramFilename   ("%SiemensIceProgs%\\IceProgram2D");                  // Only 2D reconstruction allowed

	std::cout<<"m_asSLC[0].getPhaseOffCenterPE()"<<m_asSLC[0].getPhaseOffCenterPE()<<std::endl;
    return (lStatus);
}

//. -------------------------------------------------------------------------
//.. nc_2DFLASH::check
//   Check lines at the border of k-space (gradient overflow, GSWD)
//. -------------------------------------------------------------------------
NLSStatus nc_2DFLASH::check(MrProt &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo, SEQCheckMode *)
{
    static const char *ptModule = {"nc_2DFLASH::check"};
    NLS_STATUS   lStatus = SEQU__NORMAL;

    int lL       = 0;
    int alLCk[4] = {0, 1, rSeqExpo.getMeasuredPELines() - 2,
                          rSeqExpo.getMeasuredPELines() - 1};   // line numbers for first two and last two lines

    while (lL < 4 )
    {
        OnErrorReturn(runKernel(rMrProt, rSeqLim, rSeqExpo, KERNEL_CHECK, 0, 0, alLCk[lL]));
        lL++;
    }

    return(lStatus);
}

//. -------------------------------------------------------------------------
//.. nc_2DFLASH::run
//   Run the sequence
//. -------------------------------------------------------------------------
NLSStatus nc_2DFLASH::run(MrProt  &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo)
{
    static const char *ptModule = {"nc_2DFLASH::run"};
    NLS_STATUS lStatus          = SEQU__NORMAL;

    //  Initialize the sequence test.
    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
    {
        mSEQTest(rMrProt, rSeqLim, rSeqExpo, RTEB_ORIGIN_fSEQRunStart, 0, 0, 0, 0, 0);
    }

    int32_t lLine;
	int32_t lRep;
	int32_t lDum;
    int32_t lCurrKernelCalls = 0;

    //  Send the delay between measurements (multiple measurements not used in nc_2DFLASH).
    //OnErrorReturn(fSBBMeasRepetDelaysRun (rMrProt, rSeqLim, rSeqExpo, 0));

    //  Fill some entries of the measurement data header.
    //  These entries are constant for all lines and will not change from line to line.
    m_sADC01.getMDH().addToEvalInfoMask(MDH_ONLINE);                                      // add online priority processing
    m_sADC01.getMDH().setKSpaceCentreLineNo((unsigned short)rMrProt.kSpace().echoLine()); // (= Base Resolution / 2).
    m_sADC01.getMDH().setKSpaceCentrePartitionNo(0);                                      // 2D sequence

    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
    {
        mSEQTest (rMrProt, rSeqLim, rSeqExpo, RTEB_ClockInitTR, 0, 0, m_asSLC[0].getSliceIndex(), 0, 0);
    }

	for (lDum = 0; lDum < m_lNbDummies; lDum++)
    {
		  OnErrorReturn(runKernel(rMrProt, rSeqLim, rSeqExpo, KERNEL_STEADY_STATE_DUMMY_SCAN, 0, 0, 0));
	}
    //  Loop over lines.
    for (lLine = 0; lLine < m_lLinesToMeasure; lLine++)
    {
		for (lRep=0; lRep< m_lNbOfMeas; lRep ++)
		{

        lCurrKernelCalls ++;
      
        //  Fill some entries of the measurement data header. These entries can change from line to line.
        m_sADC01.getMDH().setFirstScanInSlice(lLine == 0);                             // only true if lLine = 0 (first line)
        m_sADC01.getMDH().setLastScanInSlice (lLine == m_lLinesToMeasure - 1);         // only true if lLine = last line
        m_sADC01.getMDH().setLastScanInConcat(lLine == m_lLinesToMeasure - 1 );
        m_sADC01.getMDH().setLastScanInMeas  (lLine == m_lLinesToMeasure - 1 );

        //  Call Kernel function
        //  If the kernel is successful, then loop again; otherwise, exit run method immediately and return error code
        OnErrorReturn(runKernel(rMrProt, rSeqLim, rSeqExpo, KERNEL_IMAGE, 0, lRep, lLine));
    } 
	}

    //  Finish the sequence test.

    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
    {
        mSEQTest(rMrProt, rSeqLim, rSeqExpo, RTEB_ORIGIN_fSEQRunFinish, 0, 0, 0, 0, 0);
    }
    return(lStatus);
}

//. -------------------------------------------------------------------------
//.. nc_2DFLASH::runKernel
//   Play out primary event block
//. -------------------------------------------------------------------------
NLS_STATUS nc_2DFLASH::runKernel(MrProt &rMrProt, SeqLim &rSeqLim,  MrProtocolData::SeqExpo &rSeqExpo,
                                long lKernelMode, long /* m_lSlice */, long lRep, long lLine)
{
    static const char *ptModule = {"nc_2DFLASH::runKernel"};
    NLS_STATUS lStatus  = SEQU__NORMAL;

    //  Prepare Phase encoding and rewinder gradients.
    if(!m_sGPhasEnc.prepPE(rMrProt, lLine - m_lCenterLine))    return (m_sGPhasEnc.getNLSStatus());
    if(!m_sGPhasEncRew.prepPE(rMrProt, m_lCenterLine - lLine)) return (m_sGPhasEncRew.getNLSStatus());

    //  Fill measurement data header. These entries also can change from line to line
    m_sADC01.getMDH().setClin   ((unsigned short) lLine);
	m_sADC01.getMDH().setCrep   ((unsigned short) lRep);
    m_sADC01.getMDH().setPhaseFT(lLine == m_lLinesToMeasure - 1);

    //  Prepare FrequencyPhase objects of the RF pulse.
    m_sSRF01zSet.prepSet(m_asSLC[0], m_sSRF01);
    m_sSRF01zNeg.prepNeg(m_asSLC[0], m_sSRF01);

    //  Prepare FrequencyPhase objects of the ADC.
    m_sADC01zSet.prepSet(m_asSLC[0], m_sADC01, m_sGradRO, lLine - m_lCenterLine, 0);
    m_sADC01zNeg.prepNeg(m_asSLC[0], m_sADC01, m_sGradRO, lLine - m_lCenterLine, 0);

    //  Calculate additional phase needed for RF spoiling and add to FreqPhase objects for RF pulse and ADC.
    m_dRFSpoilIncrement += 0;//RFSPOIL_INCREMENTdeg;
    m_dRFSpoilPhase     += m_dRFSpoilIncrement;
    m_dRFSpoilPhase      = fmod(m_dRFSpoilPhase,     (double) RFMAXPHASEdeg);
    m_dRFSpoilIncrement  = fmod(m_dRFSpoilIncrement, (double) RFMAXPHASEdeg);

    m_sSRF01zSet.increasePhase(m_dRFSpoilPhase);
    m_sSRF01zNeg.decreasePhase(m_dRFSpoilPhase);
    m_sADC01zSet.increasePhase(m_dRFSpoilPhase);
    m_sADC01zNeg.decreasePhase(m_dRFSpoilPhase);

    //  Initialize real time event block with rotation matrix from slice
    fRTEBInit(m_asSLC[0].getROT_MATRIX());
	
	if (lKernelMode != KERNEL_STEADY_STATE_DUMMY_SCAN)
	{
		m_sTTL_Trig.run(0);  // Play trigger
	}

    // - **************************************** S E Q U E N C E   T I M I N G ******************************************
    // - *           Start Time    |    NCO    |   SRF   |   ADC   |            Gradient Events            |   Sync
    // - *             (usec)      |   Event   |  Event  |  Event  |    phase   |   read     |    slice    |   Event
    // - *fRTEI(                   ,           ,         ,         ,            ,            ,             ,            );
    // - *****************************************************************************************************************
    //  Play out the slice encoding gradient and oscilloscope trigger as first event in the event block.
    fRTEI(                        0,          0,        0,        0,            0,            0,  &m_sGSliSel,&m_sOscBit);

    //  Play out the RF pulse shape and set the frequency/phase object of the pulse to the new value.
    fRTEI(m_sGSliSel.getDuration()
        - m_sSRF01.getDuration() ,&m_sSRF01zSet,&m_sSRF01,        0,            0,            0,            0,         0);

    //  At the end of the RF Pulse, reset the frequency and phase object back to its value prior to the pulse.
    //  In the same event, play out the phase encoding and the read dephasing gradients.
    fRTEI(m_sGSliSel.getDuration(),&m_sSRF01zNeg,      0,         0,&m_sGPhasEnc,&m_sGReadDeph,             0,         0);

    //  Play the slice rephasing gradient beginning at the end of the slice select gradient.
    fRTEI(m_sGSliSel.getTotalTime() ,          0,      0,         0,            0,            0,&m_sGSliSelReph,       0);

    //  Play the readout gradient at its start time calculated above as a function of TE.
    fRTEI(m_sGradRO.getStartTime()  ,          0,      0,         0,            0,   &m_sGradRO,            0,         0);

	if (lKernelMode != KERNEL_STEADY_STATE_DUMMY_SCAN)
	{
    //  Turn on the ADC to measure the signal. Just as for the RF pulse, a frequency/phase object must accompany
    //  the ADC at its beginning and its end.
    fRTEI(m_sADC01.getStartTime()   ,&m_sADC01zSet,    0, &m_sADC01,            0,            0,            0,         0);
    fRTEI(m_sADC01.getStartTime() 
        + m_sADC01.getRoundedDuration(),&m_sADC01zNeg, 0,         0,            0,            0,            0,         0);
	}

    //  Play the phase encoding rewinder and the spoiler gradients.
    fRTEI(m_sGradRO.getStartTime()
        + m_sGradRO.getDuration()   ,        0,        0,         0,&m_sGPhasEncRew,          0,  &m_sGSpoil,          0);

    //  Finish the event block: include an instruction occurring at TR so that the event block is at least this long.
    //  No objects are played out at this time (indicated by all zeroes). As the timing has been checked to fit
    //  into TR, the start time of this event occurs when the last gradient has ramped down.
    fRTEI(rMrProt.tr()[0]          ,         0,        0,         0,            0,            0,            0,         0);

    // Several other methods of calling fRTEI instructions are available (MrServers\MrMeasSrv\SeqIF\libRT\libRT.h):
    // The first is to call fRTEI and only pass a start time and one object (other than gradients):
    // fRTEI(m_sGPhasEnc.getStartTime(), &m_sSRF01zNeg);
    //
    // The second is to call fRTEI and pass a start time and three gradient objects:
    // fRTEI(m_sGSpoil.getStartTime(), &m_sGPhasEncRew, 0, &m_sGSpoil);
    //
    // The last is to call fRTEI and pass only a start time:
    // fRTEI(pMrProt->tr()[0]);
    //
    // Instead of calling fRTEI, a more object-oriented approach can be used: the .run() method.
    // In this case, the start time of each object must be specified using the .setStartTime method:
    //        m_sSRF01.setStartTime(...);
    //
    // If this has been done (e.g, in prepare), then the .run() method only can be called in the event block:
    //        m_sSRF01.run();
    //
    // To use this method with a gradient object, the logical axis for the object must also be
    // specified prior to its use (in prepare or run):
    // m_sGradRO.setAxis(SEQ::AXIS_READOUT).

    // Call sequence unit test.

    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
    {
        if (lKernelMode == KERNEL_CHECK)
            mSEQTest(rMrProt, rSeqLim, rSeqExpo, RTEB_ORIGIN_fSEQCheck,     10, lLine, m_asSLC[0].getSliceIndex(), 0, 0);
        else
            mSEQTest(rMrProt, rSeqLim, rSeqExpo, RTEB_ORIGIN_fSEQRunKernel, 10, lLine, m_asSLC[0].getSliceIndex(), 0, 0);

        mSEQTest(rMrProt, rSeqLim, rSeqExpo, RTEB_ClockCheck, 10, lLine, m_asSLC[0].getSliceIndex(), 0, 0);
    }

    //  End real time event block.
    OnErrorReturn(fRTEBFinish());

    return(lStatus);
}


NLS_STATUS nc_2DFLASH::createUI (SeqLim&)
{
#ifdef WIN32

    static const char *ptModule = {"nc_2DFLASH::createUI"};

    //  ----------------------------------------------------------------------
    //  Delete existing instance if necessary
    //  ----------------------------------------------------------------------
    if(m_pUI)  
    {
        delete m_pUI;
        m_pUI = NULL;
    }

    //  ----------------------------------------------------------------------
    //  Instantiation of the UI class
    //  ----------------------------------------------------------------------
    try 
    {
        m_pUI = new nc_2DFLASHUI();
    }

    catch (...) 
    {
        delete m_pUI;
        m_pUI = NULL;

        TRACE_PUT1(TC_ALWAYS, TF_SEQ,"%s: Cannot instantiate UI class !", ptModule);
        return ( SEQU_ERROR );
    }

#endif

    return ( SEQU_NORMAL );

}   // end: nc_2DFLASH::createUI

const nc_2DFLASHUI* nc_2DFLASH::getUI (void) const
{
    return ( m_pUI );
}
